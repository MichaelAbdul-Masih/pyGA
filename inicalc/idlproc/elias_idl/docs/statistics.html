<!-- This file was generated by icmk_html_help.pro -->
<html>
 
<head>
<TITLE>Extended IDL Help</TITLE>
</head>
 
<body>
<H1>Extended IDL Help</H1>
<P>
This page was created by the IDL library routine 
<CODE>icmk_html_help</CODE>.  For more information on 
this routine, refer to the IDL Online Help Navigator 
or type: <P>
<PRE>     ? mk_html_help</PRE><P>
at the IDL command line prompt.<P>
<STRONG>Last modified: </STRONG>Mon Mar 31 16:37:18 2003.<P>
 
<HR>
 
<A NAME="ROUTINELIST">
<H1>List of Routines</H1></A>
<UL>
<LI><A HREF="#CURVEFIT">CURVEFIT</A>
Non-linear least squares fit to a function of an arbitrary
<LI><A HREF="#ICGAUSSIAN">ICGAUSSIAN</A>
Compute the 1-D Gaussian function and optionally the derivative
<LI><A HREF="#ICHISTOGRAM">ICHISTOGRAM</A>
Calculates the histogram of an array with the corresponding abcissa.
<LI><A HREF="#IC_CHISQR_PDF">IC_CHISQR_PDF</A>
This function computes the probabilty (p) such that:
<LI><A HREF="#IC_IGAMMA_PDF">IC_IGAMMA_PDF</A>
This function computes the incomplete gamma function using a series
<LI><A HREF="#IC_MEDIAN">IC_MEDIAN</A>
Median filter a time-sequence allowing for unequal time steps
<LI><A HREF="#KS3DSIG">KS3DSIG</A>
Returns significance levels for the three dimensional
<LI><A HREF="#PLOTHIST">PLOTHIST</A>
Plot the histogram of an array with the corresponding abcissa.
<LI><A HREF="#QSIMP2">QSIMP2</A>
Integrate using Simpson's rule to specified accuracy.
<LI><A HREF="#SKY_FLAT">SKY_FLAT</A>
<LI><A HREF="#SKY_STATS">SKY_STATS</A>
<LI><A HREF="#TRAPZD2">TRAPZD2</A>
Compute the nth stage of refinement of an extended trapezoidal rule.
</UL><P>
 
<HR>
 
<H1>Routine Descriptions</H1>
<A NAME="CURVEFIT">
<H2>CURVEFIT</H2></A>
<A HREF="#ICGAUSSIAN">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
       CURVEFIT

 PURPOSE:
       Non-linear least squares fit to a function of an arbitrary 
       number of parameters.  The function may be any non-linear 
       function.  If available, partial derivatives can be calculated by 
       the user function, else this routine will estimate partial derivatives
       with a forward difference approximation.

 CATEGORY:
       E2 - Curve and Surface Fitting.

 CALLING SEQUENCE:
       Result = CURVEFIT(X, Y, W, A, SIGMAA, FUNCTION_NAME = name, $
                         ITMAX=ITMAX, ITER=ITER, TOL=TOL, /NODERIVATIVE)

 INPUTS:
       X:  A row vector of independent variables.  This routine does
		not manipulate or use values in X, it simply passes X
		to the user-written function.

       Y:  A row vector containing the dependent variable.

       W:  A row vector of weights, the same length as Y.
               For no weighting,
               w(i) = 1.0.
               For instrumental weighting,
               w(i) = 1.0/y(i), etc.

       A:  A vector, with as many elements as the number of terms, that 
           contains the initial estimate for each parameter.  If A is double-
           precision, calculations are performed in double precision, 
           otherwise they are performed in single precision.

 KEYWORDS:
       FUNCTION_NAME:  The name of the function (actually, a procedure) to 
       fit.  If omitted, "FUNCT" is used. The procedure must be written as
       described under RESTRICTIONS, below.

       ITMAX:  Maximum number of iterations. Default = 20.
       ITER:   The actual number of iterations which were performed
       TOL:    The convergence tolerance. The routine returns when the
               relative decrease in chi-squared is less than TOL in an 
               interation. Default = 1.e-3.
       CHI2:   The value of chi-squared on exit
       NODERIVATIVE:   If this keyword is set then the user procedure will not
               be requested to provide partial derivatives. The partial
               derivatives will be estimated in CURVEFIT using forward
               differences. If analytical derivatives are available they
               should always be used.

 OUTPUTS:
       Returns a vector of calculated values.
       A:  A vector of parameters containing fit.

 OPTIONAL OUTPUT PARAMETERS:
       Sigmaa:  A vector of standard deviations for the parameters in A.
       ierr: =1 if failed to converge

 COMMON BLOCKS:
       NONE.

 SIDE EFFECTS:
       None.

 RESTRICTIONS:
       The function to be fit must be defined and called FUNCT,
       unless the FUNCTION_NAME keyword is supplied.  This function,
       (actually written as a procedure) must accept values of
       X (the independent variable), and A (the fitted function's
       parameter values), and return F (the function's value at
       X), and PDER (a 2D array of partial derivatives).
       For an example, see FUNCT in the IDL User's Libaray.
       A call to FUNCT is entered as:
       FUNCT, X, A, F, PDER
 where:
       X = Variable passed into CURVEFIT.  It is the job of the user-written
		function to interpret this variable.
       A = Vector of NTERMS function parameters, input.
       F = Vector of NPOINT values of function, y(i) = funct(x), output.
       PDER = Array, (NPOINT, NTERMS), of partial derivatives of funct.
               PDER(I,J) = DErivative of function at ith point with
               respect to jth parameter.  Optional output parameter.
               PDER should not be calculated if the parameter is not
               supplied in call. If the /NODERIVATIVE keyword is set in the
               call to CURVEFIT then the user routine will never need to
               calculate PDER.

 PROCEDURE:
       Copied from "CURFIT", least squares fit to a non-linear
       function, pages 237-239, Bevington, Data Reduction and Error
       Analysis for the Physical Sciences.

       "This method is the Gradient-expansion algorithm which
       combines the best features of the gradient search with
       the method of linearizing the fitting function."

       Iterations are performed until the chi square changes by
       only TOL or until ITMAX iterations have been performed.

       The initial guess of the parameter values should be
       as close to the actual values as possible or the solution
       may not converge.

 EXAMPLE:  Fit a function of the form f(x) = a * exp(b*x) + c to
	sample pairs contained in x and y.
	In this example, a=a(0), b=a(1) and c=a(2).
	The partials are easily computed symbolicaly:
		df/da = exp(b*x), df/db = a * x * exp(b*x), and df/dc = 1.0

		Here is the user-written procedure to return F(x) and
		the partials, given x:
       pro gfunct, x, a, f, pder	; Function + partials
	  bx = exp(a(1) * x)
         f= a(0) * bx + a(2)		;Evaluate the function
         if N_PARAMS() ge 4 then $	;Return partials?
		pder= [[bx], [a(0) * x * bx], [replicate(1.0, N_ELEMENTS(y))]]
       end

         x=findgen(10)			;Define indep & dep variables.
         y=[12.0, 11.0,10.2,9.4,8.7,8.1,7.5,6.9,6.5,6.1]
         w=1.0/y			;Weights
         a=[10.0,-0.1,2.0]		;Initial guess
         yfit=curvefit(x,y,w,a,sigmaa,function_name='gfunct')
	  print, 'Function parameters: ', a
         print, yfit
       end

 MODIFICATION HISTORY:
       Written, DMS, RSI, September, 1982.
       Does not iterate if the first guess is good.  DMS, Oct, 1990.
       Added CALL_PROCEDURE to make the function's name a parameter.
              (Nov 1990)
       12/14/92 - modified to reflect the changes in the 1991
            edition of Bevington (eq. II-27) (jiy-suggested by CreaSo)
       Mark Rivers, U of Chicago, Feb. 12, 1995
           - Added following keywords: ITMAX, ITER, TOL, CHI2, NODERIVATIVE
             These make the routine much more generally useful.
           - Removed Oct. 1990 modification so the routine does one iteration
             even if first guess is good. Required to get meaningful output
             for errors. 
           - Added forward difference derivative calculations required for 
             NODERIVATIVE keyword.
           - Fixed a bug: PDER was passed to user's procedure on first call, 
             but was not defined. Thus, user's procedure might not calculate
             it, but the result was then used.
      Steve Serjeant ICSTM Mar 16 1998: added ierr output
           and renamed routine iccurvefit
      6 Oct 1998: Check for finite flambda, exit with ierr if not
		(v1.1) S Serjeant
           
</PRE><P>
<STRONG>(See /contrib-linux/rsi/idl_5.4/icstm_idl/statistics/iccurvefit.pro)</STRONG><P>
<HR>
 
<A NAME="ICGAUSSIAN">
<H2>ICGAUSSIAN</H2></A>
<A HREF="#CURVEFIT">[Previous Routine]</A>
<A HREF="#ICHISTOGRAM">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	ICGAUSSIAN

 PURPOSE:
	Compute the 1-D Gaussian function and optionally the derivative 
	at an array of points.

 CALLING:
	icgaussian , xi, parms, gfun, [ pderiv ])

 INPUTS:
	xi = array, independent variable of Gaussian function.

	parms = parameters of Gaussian, 2 or 3 element array:
		parms(0) = maximum value (factor) of Gaussian,
		parms(1) = mean value (center) of Gaussian,
		parms(2) = standard deviation (sigma) of Gaussian.
		(if parms has only 2 elements then sigma taken from common).

 OUTPUT:
       gfun = array gaussian at xi

 OPTIONAL OUTPUT:
	pderiv = optional output of partial derivatives,
		computed only if parameter is present in call.

		pderiv(*,i) = partial derivative at all xi absisca values
		with respect to parms(i), i=0,1,2.

	Function returns array of Gaussian evaluated at xi.

 EXAMPLE:
	Evaulate a Gaussian centered at x=0, with sigma=1, and a peak value
	of 10 at the points 0.5 and 1.5.   Also compute the derivative

	IDL> f = gaussian( [0.5,1.5], [10,0,1], DERIV )
	==> f= [8.825,3.25].   DERIV will be a 2 x 3 array containing the
	numerical derivative at the two point with respect to the 3 parameters.
 
 COMMON BLOCKS:
	
 HISTORY:
	Written, Frank Varosi NASA/GSFC 1992.
       Adapted to work in curvefit Seb Oliver (ICSTM) July 1996
</PRE><P>
<STRONG>(See /contrib-linux/rsi/idl_5.4/icstm_idl/statistics/icgaussian.pro)</STRONG><P>
<HR>
 
<A NAME="ICHISTOGRAM">
<H2>ICHISTOGRAM</H2></A>
<A HREF="#ICGAUSSIAN">[Previous Routine]</A>
<A HREF="#IC_CHISQR_PDF">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	ICHISTOGRAM
 PURPOSE:
	Calculates the histogram of an array with the corresponding abcissa.

 CALLING SEQUENCE:
	ichistogram, arr, xhist, yhist, [, BIN=bin,  

 INPUTS:
	arr - The array to plot the histogram of.   It can include negative
		values, but non-integral values will be truncated.              

 OPTIONAL OUTPUTS:
	xhist - X vector used in making the plot  
		( = indgen( N_elements(h)) * bin + min(arr) )
	yhist - Y vector used in making the plot  (= histogram(arr/bin))

 OPTIONAL INPUT KEYWORDS:
	BIN -  The size of each bin of the histogram,  scalar (not necessarily
		integral).  If not present (or zero), the bin size is set to 1.

		Any input keyword that can be supplied to the PLOT procedure
		can also be supplied to ICHISTOGRAM.
 EXAMPLE:
	Create a vector of 1000 values derived from a gaussian of mean 0,
	and sigma of 1.    Plot the histogram of these value with a bin
	size of 0.1

	IDL> a = randomn(seed,1000)
	IDL> ichistogram,a, bin = 0.1

 MODIFICATION HISTORY:
       Copied from ASTROLIB plotist subroutine with plotting removed
                   Seb Oliver August 1996.
</PRE><P>
<STRONG>(See /contrib-linux/rsi/idl_5.4/icstm_idl/statistics/ichistogram.pro)</STRONG><P>
<HR>
 
<A NAME="IC_CHISQR_PDF">
<H2>IC_CHISQR_PDF</H2></A>
<A HREF="#ICHISTOGRAM">[Previous Routine]</A>
<A HREF="#IC_IGAMMA_PDF">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
       IC_CHISQR_PDF

 PURPOSE: 
       This function computes the probabilty (p) such that:
                   Probability(X <= v) = p
       where X is a random variable from the Chi-square distribution
       with (df) degrees of freedom.

 CATEGORY:
       Statistics.

 CALLING SEQUENCE:
       Result = chisqr_pdf(V, DF)

 INPUTS:
       V:    A scalar of type integer, float or double that specifies 
             the cutoff value.

      DF:    A positive scalar of type integer, float or double that
             specifies the degrees of freedom of the Chi-square distribution.

 EXAMPLES:
       Compute the probability that a random variable X, from the Chi-square 
       distribution with (DF = 3) degrees of freedom, is less than or equal 
       to 6.25. The result should be 0.899939 
         result = chisqr_pdf(6.25, 3)

       Compute the probability that a random variable X, from the Chi-square
       distribution with (DF = 3) degrees of freedom, is greater than 6.25. 
       The result should be 0.100061
         result = 1 - chisqr_pdf(6.25, 3)

 REFERENCE:
       ADVANCED ENGINEERING MATHEMATICS (seventh edition)
       Erwin Kreyszig
       ISBN 0-471-55380-8

 MODIFICATION HISTORY:
       Modified by:  GGS, RSI, July 1994
                     Minor changes to code. New documentation header.
	30 Oct 98: Now uses ic_igamma_pdf. Renamed ic_chisqr_pdf. S Serjeant
			
</PRE><P>
<STRONG>(See /contrib-linux/rsi/idl_5.4/icstm_idl/statistics/ic_chisqr_pdf.pro)</STRONG><P>
<HR>
 
<A NAME="IC_IGAMMA_PDF">
<H2>IC_IGAMMA_PDF</H2></A>
<A HREF="#IC_CHISQR_PDF">[Previous Routine]</A>
<A HREF="#IC_MEDIAN">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
       IC_IGAMMA_PDF

 PURPOSE:
       This function computes the incomplete gamma function using a series
       representation. It is called by the probability density functions
       in this directory. See the function IGAMMA() in the "math"
       subdirectory for the user-callable version of the incomplete gamma 
       function.

 MODIFICATION HISTORY:
       Modified by:  Jong Yi, Sept 1992
                     Increased iterations in g_series.pro
       Modified by:  GGS, RSI, July 1994
                     Minor changes to code.
	30 Oct 98: increased number of iterations in g_fract and g_series
		   Renamed ic_igamma_pdf
			S Serjeant 
</PRE><P>
<STRONG>(See /contrib-linux/rsi/idl_5.4/icstm_idl/statistics/ic_igamma_pdf.pro)</STRONG><P>
<HR>
 
<A NAME="IC_MEDIAN">
<H2>IC_MEDIAN</H2></A>
<A HREF="#IC_IGAMMA_PDF">[Previous Routine]</A>
<A HREF="#KS3DSIG">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	IC_MEDIAN

 PURPOSE:
	Median filter a time-sequence allowing for unequal time steps

 CATEGORY:
	Statistics

 CALLING SEQUENCE:
	IC_MEDIAN, TIME, DATA, FLAG, TSCALE, MED, NUSE

 INPUTS:
	time:  time-axis of data
       data:  data values
       flag:  for bad values (0. is good) 
       tscale: time-scale for median filter

 OPTIONAL INPUTS:
	Parm2:	Describe optional inputs here.
	
 KEYWORD PARAMETERS:
	skip: skip is a time scale in the centre to be skipped over

 OUTPUTS:
	MED:  Median filter at each data point
       NUSE:    Number of points used to calculate median at each point

 OPTIONAL OUTPUTS:
	Describe optional outputs here.

 COMMON BLOCKS:
	BLOCK1:	Describe any common blocks here.

 SIDE EFFECTS:
	Describe "side effects" here.

 RESTRICTIONS:
	Describe any "restrictions" here.

 PROCEDURE:
	You can describe the foobar superfloatation method being used here.

 EXAMPLE:
	Please provide a simple example here.

 MODIFICATION HISTORY:
 	Written by:	Your name here, Date.
	July, 1994	Any additional mods get described here.
</PRE><P>
<STRONG>(See /contrib-linux/rsi/idl_5.4/icstm_idl/statistics/ic_median.pro)</STRONG><P>
<HR>
 
<A NAME="KS3DSIG">
<H2>KS3DSIG</H2></A>
<A HREF="#IC_MEDIAN">[Previous Routine]</A>
<A HREF="#PLOTHIST">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
       ks3dsig

 PURPOSE:
     Returns significance levels for the three dimensional
     Kolmogorov-Smirnov test, as given in Fasano & Franceschini 1987
     Monthly Notices of the Royal Astronomical Society 225, 155.
     For values between those given in table B1 of this paper,
     an interpolation is used.

     Distribution is different at N percent significance if
     the output from this routine is less than N
     IE 99.0 is a great fit, 1.0 is a bad fit.
     Confidence levels are 100 - output
      
     Stephen Serjeant Imperial College London 17 Dec 1997
     
 CALLING SEQUENCE:
     significance = ks3dsig(Z,N,RHO)

 INPUTS:
     Zinput: 3D KS statistic, = D * sqrt(Ninput) where Ninput=sample size
             Defined as ``absolute maximum difference (multiplied by
                          sqrt(N)) between the observed and predicted
                          normalised integral distributions cumulated
                          within the eight volumes of three-dimensional
                          space defined for each data point (Xi,Yi,Zi) by
                          (x<Xi,y<Yi,z<Zi), ..., (x>Xi,y>Yi,z>Zi)
                                  (i=1,...,n) ''
     Ninput: sample size
             For two distribution case, use N1*N2/(N1+N2)
             both here and in convertion of D to Z
     RHOinput: mean average Pearson correlation coefficient
               of the 3 projections of the data 
               (ie X vs Y, Y vs Z, and X vs Z)

 OPTIONAL INPUTS:
     none

 KEYWORD PARAMETERS:
       none

 EXAMPLE:
     significance = ks3dsig(Z,N,RHO)

 MODIFICATION HISTORY:
       Written by: Stephen Serjeant Imperial College London 17 Dec 1997
       Mon Jan 19 1998: Interpolation of significance levels
       is now linear in s=alog10(100-significance) instead of linear in
       significance itself
       Wed Jan 28 1998: linear interpolation used for confidence < 30%
       Output now 100-previous output, ie 95 is a great fit at 0.1 is
       a bad fit. Stephen Serjeant
</PRE><P>
<STRONG>(See /contrib-linux/rsi/idl_5.4/icstm_idl/statistics/ks3dsig.pro)</STRONG><P>
<HR>
 
<A NAME="PLOTHIST">
<H2>PLOTHIST</H2></A>
<A HREF="#KS3DSIG">[Previous Routine]</A>
<A HREF="#QSIMP2">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	PLOTHIST
 PURPOSE:
	Plot the histogram of an array with the corresponding abcissa.

 CALLING SEQUENCE:
	plothist, arr, xhist, yhist, [, BIN=bin,   ... plotting keywords]

 INPUTS:
	arr - The array to plot the histogram of.   It can include negative
		values, but non-integral values will be truncated.              

 OPTIONAL OUTPUTS:
	xhist - X vector used in making the plot  
		( = indgen( N_elements(h)) * bin + min(arr) )
	yhist - Y vector used in making the plot  (= histogram(arr/bin))

 OPTIONAL INPUT KEYWORDS:
	BIN -  The size of each bin of the histogram,  scalar (not necessarily
		integral).  If not present (or zero), the bin size is set to 1.

		Any input keyword that can be supplied to the PLOT procedure
		can also be supplied to PLOTHIST.
 EXAMPLE:
	Create a vector of 1000 values derived from a gaussian of mean 0,
	and sigma of 1.    Plot the histogram of these value with a bin
	size of 0.1

	IDL> a = randomn(seed,1000)
	IDL> plothist,a, bin = 0.1

 MODIFICATION HISTORY:
	Written     W. Landsman            January, 1991
	Add inherited keywords W. Landsman        March, 1994
	Use ROUND instead of NINT  W. Landsman   August, 1995
</PRE><P>
<STRONG>(See /contrib-linux/rsi/idl_5.4/icstm_idl/statistics/plothist.pro)</STRONG><P>
<HR>
 
<A NAME="QSIMP2">
<H2>QSIMP2</H2></A>
<A HREF="#PLOTHIST">[Previous Routine]</A>
<A HREF="#SKY_FLAT">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	QSIMP2
 PURPOSE:
	Integrate using Simpson's rule to specified accuracy.
 EXPLANATION:
	Integrate a function to specified accuracy using the extended 
	trapezoidal rule.   Adapted from algorithm in Numerical Recipes, 
	by Press et al. (1992, 2nd edition), Section 4.2.     This procedure
	became partly obsolete in IDL V3.5 with the introduction of the 
	intrinsic function QSIMP2(), but see notes below.

 CALLING SEQUENCE:
	QSIMP2, func, A, B, S, [ EPS = , MAX_ITER = ]

 INPUTS:
	func - scalar string giving name of function of one variable to 
		be integrated
	A,B  - numeric scalars giving the lower and upper bound of the 
		integration

 OUTPUTS:
	S - Scalar giving the approximation to the integral of the specified
		function between A and B.

 OPTIONAL KEYWORD PARAMETERS:
	EPS - scalar specifying the fractional accuracy before ending the 
		iteration.  Default = 1E-6
	MAX_ITER - Integer specifying the total number iterations at which 
		QSIMP2 will terminate even if the specified accuracy has not yet
		been met.   The maximum number of function evaluations will be
		2^(MAX_ITER).    Default value is MAX_ITER = 20

 NOTES:
	(1) The function QTRAP is robust way of doing integrals that are not 
	very smooth.  However, if the function has a continuous 3rd derivative
	then QSIMP2 will likely be more efficient at performing the integral.

	(2) QSIMP2 can be much faster than the intrinsic QSIMP2() function (as
	of IDL V4.0.1).   This is because the intrinisc QSIMP2() function only 
	requires that the user supplied function accept a *scalar* variable.
	Thus on the the 16th iteration, the intrinsic QSIMP2() makes 32,767
	calls to the user function, whereas this procedure makes one call 
	with a 	32,767 element vector.
 EXAMPLE:
	Compute the integral of sin(x) from 0 to !PI/3.
    
	IDL> QSIMP2, 'sin', 0, !PI/3, S   & print, S
   
	The value obtained should be cos(!PI/3) = 0.5

 PROCEDURES CALLED:
	TRAPZD2, ZPARCHECK

 REVISION HISTORY:
	W. Landsman         ST Systems Co.         August, 1991
	Continue after max iter warning message   W. Landsman   March, 1996
</PRE><P>
<STRONG>(See /contrib-linux/rsi/idl_5.4/icstm_idl/statistics/qsimp2.pro)</STRONG><P>
<HR>
 
<A NAME="SKY_FLAT">
<H2>SKY_FLAT</H2></A>
<A HREF="#QSIMP2">[Previous Routine]</A>
<A HREF="#SKY_STATS">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
  NAME:
       SKY_FLAT
  PURPOSE: 

       Takes a 3-D image assumed (i,j,t) 
       Computes  estimates of the 2-D "sky" level from a


  CATEGORY:
          Statistics
  CALLING SEQUENCE: 
          SKY_FLAT, SKY,   FLAT, FLATVAR , method=method, niter=niter
  INPUTS: 

    SKY:  Array of data values (3-D)

  OPTIONAL INPUT PARAMETERS: 
    
  KEYED INPUTS: 
      method :  passed to sky_stats
      niter  :  number of iterations for trimming and estimating binsize
      bin    :  if set to a value on input this is the binsize used
             :  if set to a variable then on output it is array with the
                binsize used at each pixel
      dig_wid:  if set then the binsize is set so that digitisation
                at the level of dig_wid is not a problem
                dig_wid is an array with same size as cross section of sky
                or a scalar
      mask:     Array with 0 indicating value to be used
      
  KEYED OUTPUTS: 

      hist: returns the last histogram used
      gparams: returns the last gaussian parameters fitted used

  OUTPUTS: 
    FLAT: Estimate of 2-D sky/flat level
    FLATVAR:      "    "  variance about this average
 
  OPTIONAL OUTPUT PARAMETERS: 

  EXAMPLE: 

  ALGORITHM: 

  DEPENDENCIES: 

  COMMON BLOCKS: 

  SIDE EFFECTS: 

  RESTRICTIONS: 
        UNTESTED
        Gaussuian fitting only option
        Does not yet work on 2-D arrag e.g. PHOT data
        Doesn not check for errors in Sky_stats

  CALLED PROCEDURES AND FUNCTIONS: 
  MODIFICATION HISTORY: 
     21-Jun-1996  Seb Oliver
     25 Nov 1998  outputs converted to scalars if only 1 element present
		Steve Serjeant
     10-Feb-1999  Seb Oliver mask added
     22-Jul-1999 FWHM and cumalant quartiles returned Seb Oliver
</PRE><P>
<STRONG>(See /contrib-linux/rsi/idl_5.4/icstm_idl/statistics/sky_flat.pro)</STRONG><P>
<HR>
 
<A NAME="SKY_STATS">
<H2>SKY_STATS</H2></A>
<A HREF="#SKY_FLAT">[Previous Routine]</A>
<A HREF="#TRAPZD2">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
  NAME:
       SKY_STATS
  PURPOSE: 

       Computes  estimates of the "sky" level from a
       data array, together with variance and in some cases
       skewness and kurtosis
       Any triming (e.g. for Cosmic rays) should be done before
       hand i.e. this can be called iteratively



  CATEGORY:
          Statistics
  CALLING SEQUENCE: 
          SKY_STATS, SKY0,  SKYMEAN,  SKYVAR, [SKYSKEW, SKYKUR, 
          METHOD=METHOD, HIST=HIST, binsize=binsize, g1=g1, chi2=chi2, 
          /initial]
  INPUTS: 

    SKY0:  Array of data values (any dimension)

  OPTIONAL INPUT PARAMETERS: 
    
  KEYED INPUTS: 
    METHOD: Method for computing mean (Default gfit)
          = moments  standard moments analysis
          = mmm      DAOphot mmm method
          = gfit     Gaussian Fit to histogram
          = qgfit    Gaussian Fit + quadratic to histogram
          = wgfit    Gaussian Fit weighted by number in bins
    HIST:  If set HIST is a (2 by N) array containg a histogram of the counts
    BINSIZE: If set then is  the width of the bins used
           : if set to a variable with value 0 then the binsize used is returned
    G1:  If set returns gaussian fitting function
    CHI2: CHI^2 of Gaussian fit
    INITIAL: If set then the values of skymean and skyvar are used to 
             as initial guess in order to estimate bin widths
             otherwise a moments analysis is used
             N.B. After the initial guess the binsize is then 
                  further adjusted by estimating the variance
                  from the peak of the histogram
    DIG_WID: For digitised data this specifies the digitisation
             levels and bin widths are not allowed to drop below this
             Also the data values are "blured" on the digitisation scale
             using a uniform random distribution.
    NOZEROFIT: Suppress fitting of empty bins in histogram

    FWHM:  estimate of the start and end position of the Half maxima
          points i.e. real
          FWHM=FWHM[1]-FWHM[0]=2.*sqrt(2.*alog(2.))*sigma for a Gaussian
    FWQM:  estimate of the start and end position of the Half maxima
          points i.e. real
          FWQM=FWQM[1]-FWQM[0]=2.*sqrt(2.*alog(4.))*sigma for a Gaussian

    CUM_SIGMAS2:  estimates of the 
      [0.0013498980,0.022750132,  0.15865525, 0.50000000, 0.84134475,
      0.97724987 , 0.99865010]  quartiles (corresponding to [-3,-2,-1,0,1,2,3] sigma
      for a Gaussian) from the cumulative distribution

    moms:  resturns output from MOMENT function

  OUTPUTS: 
    SKYMEAN: Estimate of average sky level
    SKYVAR:      "    "  variance about this average
 
  OPTIONAL OUTPUT PARAMETERS: 
    SKYKUR:      "    "  kurtosis
    SKYKUR:      "    "  kurtosis
    IERR: =0 initially
          =ierr+1 if too few points
          =ierr+2 if all data the same
          =ierr+4 if iccurvefit failed to converge
          =ierr+8 on failiure in calculations of fwhm etc. 

  EXAMPLE:

 IDL> ran=randomn(seed,100000)*2.
 IDL> mo=moment(ran)
 IDL> print,mo(0),sqrt(mo(1))/sqrt(100000)
 IDL> sky_stats,ran,sm,'gfit',g1=g1,hist=h1
 IDL> print,sm
 IDL> plot,h1(0,*),h1(1,*),psym=10
 IDL> oplot,h1(0,*),g1
 IDL> ran1=round(ran)
 IDL> sky_stats,ran,sm1,'gfit',g1=g1,hist=h1,dig_wid=1.
 IDL> ran2=round(ran)+0.1
 IDL> sky_stats,ran2,sm2,'gfit',g1=g1,hist=h1,dig_wid=1.
 IDL> print,mo(0),sqrt(mo(1))/sqrt(100000),sm,sm1,sm2


  ALGORITHM: 

  DEPENDENCIES: 

  COMMON BLOCKS: 

  SIDE EFFECTS: 

  RESTRICTIONS: 
        UNTESTED
        Gaussuian fitting at moment allows a second order fit to the
        background under the Gaussian
  CALLED PROCEDURES AND FUNCTIONS: 
  MODIFICATION HISTORY: 
     21-Jun-1996  Seb Oliver
      6-Feb-1997 Blurring of digitised data introduced, for simplicity
                 and speed this is done using a randomisation approach.
     13-mar-1998 check for few elements or all data the same value Seb
     16-Mar-1998 NOZEROFIT keyword and IERR flag added - Steve Serjeant
                 Also uses iccurvefit instead of curvefit 
     7-Sept-1998 Bug fix in nozerofit option - previously the option
		  was never being implemented. S Serjeant
     19-May-1999 Outputs useful vbles when too few points to fit 
		  or data all the same S Serjeant
     22-Jul-1999 FWHM and cumalant quartiles returned Seb Oliver v1.2
     26-Jul-1999 Added checks for >1 element in interpol calls.
                 Having 1 element may be symptomatic of other errors
                 so added ierr = ierr+8 in these and related
                 situations. 
                 Stephen Serjeant version 1.3
     28 Aug 1999 Changed loop variables from int to long
                 s serjeant version 1.4
</PRE><P>
<STRONG>(See /contrib-linux/rsi/idl_5.4/icstm_idl/statistics/sky_stats.pro)</STRONG><P>
<HR>
 
<A NAME="TRAPZD2">
<H2>TRAPZD2</H2></A>
<A HREF="#SKY_STATS">[Previous Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	TRAPZD2
 PURPOSE:
	Compute the nth stage of refinement of an extended trapezoidal rule.
	This procedure is called by QSIMP and QTRAP.   Algorithm from Numerical
	Recipes, Section 4.2.   TRAPZD2 is meant to be called iteratively from
	a higher level procedure.

 CALLING SEQUENCE:
	TRAPZD2, func, A, B, S, step

 INPUTS:
	func - scalar string giving name of function to be integrated.   This
		must be a function of one variable.
	A,B -  scalars giving the limits of the integration

 INPUT-OUTPUT:
	S -    scalar giving the total sum from the previous interations on 
		input and the refined sum after the current iteration on output.

	step - LONG scalar giving the number of points at which to compute the
		function for the current iteration.   If step is not defined on
		input, then S is intialized using the average of the endpoints
		of limits of integration.

 NOTES:
	(1) TRAPZD2 will check for math errors when computing the function at the
	endpoints, but not on subsequent iterations.

	(2) TRAPZD2 always uses double precision to sum the function values
	but the call to the user-supplied is double precision only if one of
	the limits A or B is double precision.
 REVISION HISTORY:
	Written         W. Landsman                 August, 1991
	Always use double precision for TOTAL       March, 1996
</PRE><P>
<STRONG>(See /contrib-linux/rsi/idl_5.4/icstm_idl/statistics/trapzd2.pro)</STRONG><P>
<HR>
 
</body>
</html>
