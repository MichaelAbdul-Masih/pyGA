PRO SKY_STATS, SKY0,  SKYMEAN,  SKYVAR, SKYSKEW, SKYKUR, METHOD=METHOD, $
               HIST=HIST, binsize=binsize, g1=g1, chi2=chi2, initial=initial, $
               dig_wid=dig_wid,gparams=gparams
;+ 
;  NAME:
;       SKY_STATS
;  PURPOSE: 
;
;       Computes  estimates of the "sky" level from a
;       data array, together with variance and in some cases
;       skewness and kurtosis
;       Any triming (e.g. for Cosmic rays) should be done before
;       hand i.e. this can be called itteratively
;
;
;
;  CATEGORY:
;          Statistics
;  CALLING SEQUENCE: 
;          SKY_STATS, SKY0,  SKYMEAN,  SKYVAR, [SKYSKEW, SKYKUR, 
;          METHOD=METHOD, HIST=HIST, binsize=binsize, g1=g1, chi2=chi2, 
;          /initial]
;  INPUTS: 
;
;    SKY0:  Array of data values (any dimension)
;
;  OPTIONAL INPUT PARAMETERS: 
;    
;  KEYED INPUTS: 
;    METHOD: Method for computing mean (Default gfit)
;          = moments  standard moments analysis
;          = mmm      DAOphot mmm method
;          = gfit     Gaussian Fit to histogram
;          = qgfit    Gaussian Fit + quadratic to histogram
;          = wgfit    Gaussian Fit weighted by number in bins
;    HIST:  If set HIST is a (2 by N) array containg a histogram of the counts
;    BINSIZE: If set then is  the width of the bins used
;           : if set to a variable with value 0 then the binsize used is returned
;    G1:  If set returns gaussian fitting function
;    CHI2: CHI^2 of Gaussian fit
;    INITIAL: If set then the values of skymean and skyvar are used to 
;             as initial guess in order to estimate bin widths
;             otherwise a moments analysis is used
;             N.B. After the initial guess the binsize is then 
;                  further adjusted by estimating the variance
;                  from the peak of the histogram
;    DIG_WID: For digitised data this specifies the digitisation
;             levels and bin widths are not allowed to drop below this
;             Also the data values are "blured" on the digitisation scale
;             using a uniform random distribution.
;
;
;  OUTPUTS: 
;    SKYMEAN: Estimate of average sky level
;    SKYVAR:      "    "  variance about this average
; 
;  OPTIONAL OUTPUT PARAMETERS: 
;    SKYKUR:      "    "  kurtosis
;    SKYKUR:      "    "  kurtosis
;
;  EXAMPLE:
;
; IDL> ran=randomn(seed,100000)*2.
; IDL> mo=moment(ran)
; IDL> print,mo(0),sqrt(mo(1))/sqrt(100000)
; IDL> sky_stats,ran,sm,'gfit',g1=g1,hist=h1
; IDL> print,sm
; IDL> plot,h1(0,*),h1(1,*),psym=10
; IDL> oplot,h1(0,*),g1
; IDL> ran1=round(ran)
; IDL> sky_stats,ran,sm1,'gfit',g1=g1,hist=h1,dig_wid=1.
; IDL> ran2=round(ran)+0.1
; IDL> sky_stats,ran2,sm2,'gfit',g1=g1,hist=h1,dig_wid=1.
; IDL> print,mo(0),sqrt(mo(1))/sqrt(100000),sm,sm1,sm2
;
;
;  ALGORITHM: 
;
;  DEPENDENCIES: 
;
;  COMMON BLOCKS: 
;
;  SIDE EFFECTS: 
;
;  RESTRICTIONS: 
;        UNTESTED
;        Gaussuian fitting at moment allows a second order fit to the
;        background under the Gaussian
;  CALLED PROCEDURES AND FUNCTIONS: 
;  MODIFICATION HISTORY: 
;     21-Jun-1996  Seb Oliver
;      6-Feb-1997 Bluring of digitised data introduced, for simplicity
;                 and speed this is done using a randomisation approach.
;-
 
; ------------------------------------------------------------
;  common blocks 
; ------------------------------------------------------------
 

; ------------------------------------------------------------
;  on error conditions
; ------------------------------------------------------------
  ON_ERROR,2
 

; ------------------------------------------------------------
;  parameter checking
; ------------------------------------------------------------
   if not keyword_set(method) then method='gfi'


   case strlowcase(strmid(method,0,3)) of
       'mom': imeth=1
       'mmm': imeth=2
       'gfi': imeth=3
       'qgf': imeth=4
       'wgf': imeth=5
       else: begin
              print,'Using Gaussian Fit to Histogram'
              imeth=3
             end
   endcase


   if not keyword_set(dig_wid) then begin
      dig_wid=0.
      sky=sky0
   endif else begin
      blur=(randomu(seed,n_elements(sky0))-0.5)*dig_wid
      sky=sky0+blur
   endelse

; ------------------------------------------------------------
;  function body
; ------------------------------------------------------------

; moments analysis done if specified or if skymean and skyvar from 
; calling routine are not to be used as initial guesses
; 
  if imeth eq 1 or (imeth gt 2 and not keyword_set(initial)) then begin
    moms=moment(sky)
    skymean=moms(0)
    skyvar=moms(1)
    skyskew=moms(2)
    skykur=moms(3)
  endif

; doing DAOPHOT method
  if(imeth eq 2) then begin 
    mmm,sky,skymean,skyvar,skyskew
    skyvar=skyvar^2
  endif


; If we want a histogram or we are fitting a Gaussian we need the
; histogram
  if(keyword_set(hist) or imeth eq 3 or imeth eq 4 or imeth eq 5) then begin

; setting bin_size to be such that there are roughly 
; 5% Possion errors (i.e. 400 points) in a bin at 1 sigma
; although they are not allowed to get larger than 0.5 sigma    
; Also bin width is not allowed smaller than dig_wid

      if not keyword_set(binsize)  then begin 

         binsize=min([0.5, 400./n_elements(sky)/0.242])*sqrt(skyvar)

; checking that the binsize is not larger than 0.5 sigma as
; estimated from the histogram peak
;         if not keyword_set(initial) then begin
            y = round( ( sky / binsize))
            h1 = histogram( y )
            sigma=n_elements(sky)/max(h1)*binsize/sqrt(2.*!pi)
            if binsize gt 0.5 * sigma then binsize=0.5*sigma

; Setting the binsiz to an integer multiple of the 
; digitisation scale
	    if(dig_wid gt 0)then binsize=(fix(binsize/dig_wid)+1.)*dig_wid
;            if binsize lt dig_wid then binsize=dig_wid

;         endif
       endif


; Compute the histogram and abcissa.

         y = round( ( sky / binsize))

         h1 = histogram( y )
         N_hist = N_elements( h1 )
         x1 = lindgen( N_hist ) * binsize + min(y*binsize) 

         hist=transpose([[x1],[h1]])

  endif

; Doing Gaussian Fitting Method
  if (imeth eq 3 or imeth eq 5) then begin

;      gparams=[n_elements(sky)/binsize/sqrt(skyvar*2.*!pi),$
;               skymean,sqrt(skyvar)]

; First Guess at parameters from max of histogram this is a very
; robust estimate

      dn=max(h1,imax)
      skymean=x1(imax)
      skysig=n_elements(sky)/dn*binsize/sqrt(2.*!pi)
      gparams=[dn,skymean,skysig]


      if imeth eq 3 then begin
; weights set equal
        w=replicate(1.,n_hist)
      endif else begin
; weights are 1/variance 
        icgaussian,x1,gparams,w
        w=1./w
      endelse
      good=where(w gt 0.,count)
;stop
      if (count gt 3)then begin
        g1=curvefit(x1,h1,w,gparams,funct='icgaussian',chi2=chi2)
      endif else begin
        print,'Not enough points'
      endelse
      skymean=gparams(1)
      skyvar=gparams(2)^2

  endif

; Doing Gaussian + quadratic Fitting Method
  if (imeth eq 4) then begin

; First Guess at parameters from max of histogram this is a very
; robust estimate

      dn=max(h1,imax)
      skymean=x1(imax)
      skysig=n_elements(sky)/dn*binsize/sqrt(2.*!pi)
      gparams=[dn,skymean,skysig]


      g1=gaussfit(x1,h1,gparams)
      skymean=gparams(1)
      skyvar=gparams(2)^2
  endif

 END


